<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuestScript PRO - Enhanced Gaming Language</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e8e8e8;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 2px solid #4ecca3;
            position: relative;
        }
        
        .sale-header {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 14px;
            font-weight: bold;
        }
        
        h1 {
            color: #4ecca3;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(78, 204, 163, 0.5);
        }
        
        .pro-badge {
            display: inline-block;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #1a1a2e;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 10px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .subtitle {
            color: #a8dadc;
            font-size: 1.1em;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid rgba(78, 204, 163, 0.3);
        }
        
        .panel h2 {
            color: #4ecca3;
            margin-bottom: 15px;
            font-size: 1.5em;
        }
        
        #code-editor {
            width: 100%;
            min-height: 400px;
            background: #0f0f23;
            color: #4ecca3;
            border: 2px solid #4ecca3;
            border-radius: 5px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        button {
            background: #4ecca3;
            color: #1a1a2e;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #45b393;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 204, 163, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .secondary-btn {
            background: rgba(78, 204, 163, 0.2);
            color: #4ecca3;
            border: 1px solid #4ecca3;
        }
        
        #game-canvas {
            width: 100%;
            height: 400px;
            background: #0a0a15;
            border: 2px solid #4ecca3;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }
        
        .sprite {
            position: absolute;
            font-size: 32px;
            transition: all 0.3s ease;
            cursor: pointer;
            user-select: none;
        }
        
        .sprite.damaged {
            animation: shake 0.3s;
            filter: brightness(0.5);
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        #output {
            background: #0f0f23;
            border: 2px solid #4ecca3;
            border-radius: 5px;
            padding: 15px;
            min-height: 250px;
            max-height: 450px;
            overflow-y: auto;
            font-size: 14px;
            margin-top: 15px;
        }
        
        .fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(78, 204, 163, 0.3);
            border: 2px solid #4ecca3;
            color: #4ecca3;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 20px;
            z-index: 100;
            transition: all 0.3s;
        }
        
        .fullscreen-btn:hover {
            background: rgba(78, 204, 163, 0.5);
            transform: scale(1.1);
        }
        
        #game-canvas.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999;
            border-radius: 0;
        }
        
        .combat-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ffd700;
            padding: 30px;
            border-radius: 15px;
            z-index: 10000;
            text-align: center;
            min-width: 300px;
        }
        
        .combat-prompt h3 {
            color: #ffd700;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .combat-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }
        
        .combat-btn:hover {
            background: #ff5252;
            transform: scale(1.05);
        }
        
        .combat-btn.defend {
            background: #4ecca3;
        }
        
        .combat-btn.defend:hover {
            background: #45b393;
        }
        
        .output-line {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #4ecca3;
            padding-left: 10px;
        }
        
        .output-error {
            color: #ff6b6b;
            border-left-color: #ff6b6b;
        }
        
        .output-success {
            color: #4ecca3;
        }
        
        .output-warning {
            color: #ffd700;
            border-left-color: #ffd700;
        }
        
        .examples {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid rgba(78, 204, 163, 0.3);
        }
        
        .example-btn {
            background: rgba(78, 204, 163, 0.2);
            color: #4ecca3;
            border: 1px solid #4ecca3;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .example-btn:hover {
            background: rgba(78, 204, 163, 0.3);
        }
        
        .syntax-guide {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 12px;
            line-height: 1.8;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .syntax-guide code {
            background: #0f0f23;
            padding: 2px 6px;
            border-radius: 3px;
            color: #4ecca3;
        }
        
        .syntax-category {
            margin: 15px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        
        .syntax-category h3 {
            color: #ffd700;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .health-bar {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 10px;
            border-radius: 5px;
            font-size: 18px;
        }
        
        .heart {
            display: inline-block;
            margin: 0 1px;
            transition: all 0.3s;
        }
        
        .heart.lost {
            opacity: 0.2;
            filter: grayscale(100%);
        }
        
        .score-display {
            position: absolute;
            top: 50px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            color: #ffd700;
        }
        
        .inventory-display {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .inventory-display:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.05);
        }
        
        .inventory-menu {
            position: absolute;
            bottom: 60px;
            left: 10px;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #4ecca3;
            padding: 20px;
            border-radius: 10px;
            min-width: 300px;
            max-width: 400px;
            z-index: 1000;
            display: none;
        }
        
        .inventory-menu.open {
            display: block;
        }
        
        .inventory-menu h3 {
            color: #4ecca3;
            margin-bottom: 15px;
            border-bottom: 2px solid #4ecca3;
            padding-bottom: 10px;
        }
        
        .inventory-item {
            background: rgba(78, 204, 163, 0.1);
            border: 2px solid #4ecca3;
            padding: 12px;
            margin: 8px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s;
        }
        
        .inventory-item:hover {
            background: rgba(78, 204, 163, 0.2);
            transform: translateX(5px);
        }
        
        .inventory-item.equipped {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
        }
        
        .inventory-item-name {
            color: #e8e8e8;
            font-weight: bold;
        }
        
        .inventory-item-stats {
            color: #ffd700;
            font-size: 12px;
        }
        
        .equip-btn {
            background: #4ecca3;
            color: #1a1a2e;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .equip-btn:hover {
            background: #45b393;
        }
        
        .equip-btn.equipped {
            background: #ff6b6b;
        }
        
        .drop-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.3s;
            margin-left: 5px;
        }
        
        .drop-btn:hover {
            background: #ff5252;
        }
        
        .infinite-mode-display {
            position: absolute;
            top: 90px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #ffd700;
            display: none;
        }
        
        .infinite-mode-display.active {
            display: block;
        }
        
        .zone-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            color: #ffd700;
            display: none;
            text-align: right;
        }
        
        .zone-display.active {
            display: block;
        }
        
        .zone-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .zone-progress {
            font-size: 11px;
            color: #4ecca3;
        }
        
        .card-selection-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        .card-selection-overlay.active {
            display: flex;
        }
        
        .card-selection-container {
            text-align: center;
        }
        
        .card-selection-title {
            color: #ffd700;
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        
        .card-selection-subtitle {
            color: #4ecca3;
            font-size: 18px;
            margin-bottom: 40px;
        }
        
        .cards-container {
            display: flex;
            gap: 30px;
            justify-content: center;
        }
        
        .card {
            width: 200px;
            height: 280px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 3px solid #4ecca3;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 10px 40px rgba(78, 204, 163, 0.6);
            border-color: #ffd700;
        }
        
        .card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent,
                rgba(78, 204, 163, 0.1),
                transparent
            );
            transform: rotate(45deg);
            transition: all 0.5s;
        }
        
        .card:hover::before {
            left: 100%;
        }
        
        .card-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .card-name {
            color: #ffd700;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .card-description {
            color: #e8e8e8;
            font-size: 13px;
            line-height: 1.5;
            margin-bottom: 15px;
        }
        
        .card-effect {
            color: #4ecca3;
            font-size: 12px;
            font-weight: bold;
        }
        
        .boss-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.95);
            border: 5px solid #ffd700;
            padding: 40px;
            border-radius: 20px;
            z-index: 9999;
            text-align: center;
            animation: boss-pulse 1s infinite;
        }
        
        @keyframes boss-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }
        
        .boss-warning h2 {
            color: #ffd700;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }
        
        .boss-warning p {
            color: white;
            font-size: 24px;
        }
        
        .active-buffs {
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 11px;
            max-width: 200px;
            display: none;
        }
        
        .active-buffs.visible {
            display: block;
        }
        
        .buff-item {
            color: #4ecca3;
            margin: 3px 0;
            padding: 3px;
            border-left: 2px solid #4ecca3;
            padding-left: 5px;
        }
        
        .difficulty-bar {
            width: 100px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .difficulty-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecca3, #ffd700, #ff6b6b);
            transition: width 0.3s;
        }
        
        .no-items {
            color: #888;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }
        
        .collision-effect {
            position: absolute;
            pointer-events: none;
            animation: explode 0.5s forwards;
        }
        
        @keyframes explode {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }
        
        .feature-highlight {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid #ffd700;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .feature-highlight h3 {
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .footer {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            font-size: 12px;
        }
        
        .footer-brand {
            background: linear-gradient(90deg, 
                #ff0000 0%, 
                #ff7f00 14%, 
                #ffff00 28%, 
                #00ff00 42%, 
                #0000ff 57%, 
                #4b0082 71%, 
                #9400d3 85%, 
                #ff0000 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: bold;
            letter-spacing: 2px;
            animation: rainbow-shift 3s linear infinite;
            background-size: 200% 100%;
        }
        
        @keyframes rainbow-shift {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }
        
        .keyboard-control-panel {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #ffd700;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }
        
        .control-info {
            color: #ffd700;
            font-size: 12px;
            margin-top: 10px;
        }
        
        .sprite-selector {
            background: #0f0f23;
            color: #4ecca3;
            border: 2px solid #4ecca3;
            padding: 8px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 5px;
        }
        
        .controlled-sprite {
            box-shadow: 0 0 20px #ffd700;
            border: 2px solid #ffd700;
            border-radius: 50%;
        }
        
        .sale-price {
            font-size: 14px;
            font-weight: bold;
        }
        
        .original-price {
            color: #ff6b6b;
            text-decoration: line-through;
            margin-right: 10px;
        }
        
        .sale-price-now {
            color: #4ecca3;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(78, 204, 163, 0.5);
        }
        
        .sale-badge {
            display: inline-block;
            background: #ff6b6b;
            color: white;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            margin-right: 5px;
            animation: pulse 2s infinite;
        }
        
        /* Custom Scrollbars */
        #code-editor::-webkit-scrollbar,
        #output::-webkit-scrollbar,
        .syntax-guide::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        #code-editor::-webkit-scrollbar-track,
        #output::-webkit-scrollbar-track,
        .syntax-guide::-webkit-scrollbar-track {
            background: #0a0a15;
            border-radius: 10px;
            border: 1px solid rgba(78, 204, 163, 0.2);
        }
        
        #code-editor::-webkit-scrollbar-thumb,
        #output::-webkit-scrollbar-thumb,
        .syntax-guide::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #4ecca3 0%, #45b393 100%);
            border-radius: 10px;
            border: 2px solid #0a0a15;
            transition: all 0.3s;
        }
        
        #code-editor::-webkit-scrollbar-thumb:hover,
        #output::-webkit-scrollbar-thumb:hover,
        .syntax-guide::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #5efcb3 0%, #4ecca3 100%);
            box-shadow: 0 0 10px rgba(78, 204, 163, 0.6);
        }
        
        #code-editor::-webkit-scrollbar-thumb:active,
        #output::-webkit-scrollbar-thumb:active,
        .syntax-guide::-webkit-scrollbar-thumb:active {
            background: linear-gradient(180deg, #3edc93 0%, #35a383 100%);
        }
        
        #code-editor::-webkit-scrollbar-corner,
        #output::-webkit-scrollbar-corner,
        .syntax-guide::-webkit-scrollbar-corner {
            background: #0a0a15;
        }
        
        /* Firefox scrollbar styling */
        #code-editor,
        #output,
        .syntax-guide {
            scrollbar-width: thin;
            scrollbar-color: #4ecca3 #0a0a15;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="sale-header">
                <span class="sale-badge">SALE</span>
                <span class="original-price">$4.99</span>
                <span class="sale-price-now">$0.00</span>
            </div>
            <h1>‚öîÔ∏è QuestScript <span class="pro-badge">PRO - FREE!</span></h1>
            <p class="subtitle">Enhanced Gaming Programming Language - All Premium Features Unlocked!</p>
        </header>
        
        <div class="feature-highlight">
            <h3>üéÅ NEW PRO FEATURES - ALL FREE:</h3>
            Collision Detection ‚Ä¢ Attack System ‚Ä¢ Inventory ‚Ä¢ Teleport ‚Ä¢ Loops ‚Ä¢ Sound Effects ‚Ä¢ Variables ‚Ä¢ Random Numbers ‚Ä¢ Patrol Paths ‚Ä¢ And More!
        </div>
        
        <div class="main-content">
            <div class="panel">
                <h2>üìù Code Editor</h2>
                <textarea id="code-editor" spellcheck="false">// QuestScript PRO - Try the new features! üéÆ

SPAWN hero AT 50, 50 AS üßô
SPAWN enemy AT 350, 200 AS üëπ
SPAWN treasure AT 400, 100 AS üíé
SPAWN potion AT 200, 250 AS üß™

SET hero.health TO 100
SET hero.score TO 0
SET hero.damage TO 25

// New! Inventory system
INVENTORY hero ADD "sword"
INVENTORY hero ADD "shield"

SAY "Epic quest begins!" FOR 2000
WAIT 2000

// New! Teleport command
TELEPORT hero TO 150, 150
SAY "Teleported!" FOR 1000
WAIT 1000

// New! Loops
REPEAT 3 TIMES
    MOVE hero RIGHT 50
    WAIT 500
END

// New! Attack with collision detection
ATTACK hero TARGETS enemy WITH 25 DAMAGE
WAIT 1500

// New! Random movement
SET randomX TO RANDOM 100, 400
SET randomY TO RANDOM 50, 300
MOVE enemy TO randomX, randomY
WAIT 1000

// Check collision and pick up items
IF hero COLLIDES treasure THEN
    ADD 100 TO hero.score
    REMOVE treasure
    SAY "Treasure collected! üí∞" FOR 1500
END

SAY "Quest complete! Score: " + hero.score FOR 2000</textarea>
                
                <div class="button-group">
                    <button onclick="runCode()">‚ñ∂Ô∏è RUN QUEST</button>
                    <button onclick="stopCode()" class="secondary-btn">‚èπÔ∏è STOP</button>
                    <button onclick="clearCanvas()" class="secondary-btn">üóëÔ∏è CLEAR</button>
                    <button onclick="toggleSound()" class="secondary-btn">üîä SOUND: <span id="sound-status">ON</span></button>
                    <button onclick="toggleInfiniteMode()" class="secondary-btn" id="infinite-mode-btn">üåç INFINITE MODE</button>
                </div>
                
                <div id="output"></div>
            </div>
            
            <div class="panel">
                <h2>üéÆ Game World</h2>
                <div id="game-canvas">
                    <button class="fullscreen-btn" onclick="toggleFullscreen()" title="Toggle Fullscreen">‚õ∂</button>
                    <div class="health-bar" id="health-display">
                        <span class="heart">‚ù§Ô∏è</span><span class="heart">‚ù§Ô∏è</span><span class="heart">‚ù§Ô∏è</span><span class="heart">‚ù§Ô∏è</span><span class="heart">‚ù§Ô∏è</span>
                    </div>
                    <div class="score-display" id="score-display">‚≠ê Score: 0</div>
                    <div class="infinite-mode-display" id="infinite-display">
                        üåç Infinite Mode<br>
                        Difficulty: <span id="difficulty-level">1</span>
                        <div class="difficulty-bar">
                            <div class="difficulty-fill" id="difficulty-fill" style="width: 10%"></div>
                        </div>
                    </div>
                    <div class="zone-display" id="zone-display">
                        <div class="zone-name" id="zone-name">Zone 1: Plains</div>
                        <div class="zone-progress" id="zone-progress">0/100 to next zone</div>
                    </div>
                    <div class="active-buffs" id="active-buffs">
                        <strong style="color: #ffd700;">üé¥ Active Cards:</strong>
                        <div id="buffs-list"></div>
                    </div>
                    <div class="inventory-display" id="inventory-display" onclick="toggleInventoryMenu()">
                        üéí Inventory (Click)
                    </div>
                    <div class="inventory-menu" id="inventory-menu">
                        <h3>‚öîÔ∏è Equipment</h3>
                        <div id="inventory-items">
                            <div class="no-items">No items in inventory</div>
                        </div>
                    </div>
                </div>
                
                <!-- Card Selection Overlay -->
                <div class="card-selection-overlay" id="card-overlay">
                    <div class="card-selection-container">
                        <h1 class="card-selection-title" id="card-title">üé¥ Choose Your Card!</h1>
                        <p class="card-selection-subtitle" id="card-subtitle">Select 1 card to gain its power</p>
                        <div class="cards-container" id="cards-container">
                            <!-- Cards will be generated here -->
                        </div>
                    </div>
                </div>
                
                <div class="syntax-guide">
                    <div class="syntax-category">
                        <h3>‚≠ê BASIC COMMANDS</h3>
                        <code>SPAWN name AT x, y AS emoji</code><br>
                        <code>MOVE name UP/DOWN/LEFT/RIGHT distance</code><br>
                        <code>MOVE name TO x, y</code> (absolute)<br>
                        <code>TELEPORT name TO x, y</code> (instant)<br>
                        <code>REMOVE name</code> (delete sprite)<br>
                        <code>WAIT milliseconds</code>
                    </div>
                    
                    <div class="syntax-category">
                        <h3>‚≠ê VARIABLES & MATH</h3>
                        <code>SET name.prop TO value</code><br>
                        <code>SET var TO RANDOM min, max</code><br>
                        <code>ADD value TO variable</code><br>
                        <code>SUBTRACT value FROM variable</code><br>
                        <code>MULTIPLY variable BY value</code><br>
                        <code>DIVIDE variable BY value</code>
                    </div>
                    
                    <div class="syntax-category">
                        <h3>‚≠ê COMBAT & INVENTORY</h3>
                        <code>ATTACK attacker TARGETS target WITH damage</code><br>
                        <code>HEAL name BY amount</code><br>
                        <code>INVENTORY name ADD "item"</code><br>
                        <code>INVENTORY name REMOVE "item"</code><br>
                        <code>INVENTORY name HAS "item"</code> (condition)
                    </div>
                    
                    <div class="syntax-category">
                        <h3>‚≠ê CONTROL FLOW</h3>
                        <code>IF condition THEN ... END</code><br>
                        <code>REPEAT n TIMES ... END</code><br>
                        <code>name COLLIDES other</code> (condition)<br>
                        <code>SAY "text" FOR ms</code><br>
                        <code>PLAY SOUND "type"</code> (hit/coin/win/lose)
                    </div>
                </div>
                
                <div class="keyboard-control-panel">
                    <h3 style="color: #ffd700; margin-bottom: 10px;">üéÆ PRO: Keyboard Control (FREE!)</h3>
                    <button onclick="toggleKeyboardControl()" class="secondary-btn" id="keyboard-toggle-btn">
                        üéπ Enable WASD Control
                    </button>
                    <select id="sprite-selector" class="sprite-selector" onchange="updateControlledSprite()">
                        <option value="">Select sprite to control...</option>
                    </select>
                    <div class="control-info" id="control-info">
                        Press W/A/S/D to move ‚Ä¢ Speed: 20px per key
                    </div>
                </div>
            </div>
        </div>
        
        <div class="examples">
            <h2>üìö Example Quests (Now with PRO Features!)</h2>
            <button class="example-btn" onclick="loadExample('rpg')">üéÆ Full RPG Battle</button>
            <button class="example-btn" onclick="loadExample('treasure')">üí∞ Treasure Hunt</button>
            <button class="example-btn" onclick="loadExample('maze')">üó∫Ô∏è Auto-Patrol Maze</button>
            <button class="example-btn" onclick="loadExample('boss')">üëπ Boss Fight</button>
            <button class="example-btn" onclick="loadExample('random')">üé≤ Random Events</button>
        </div>
        
        <div class="footer">
            <div class="footer-brand">V4N1TY LCD           LONDON           .</div>
        </div>
    </div>
    
    <script>
        let sprites = {};
        let gameState = {};
        let isRunning = false;
        let soundEnabled = true;
        let inventories = {};
        let keyboardControlEnabled = false;
        let controlledSprite = null;
        let keyboardListener = null;
        let combatInProgress = false;
        let treasuresCollected = [];
        let equippedItems = {};
        let maxHealth = 5;
        
        // Infinite mode variables
        let infiniteModeEnabled = false;
        let difficultyLevel = 1;
        let enemySpawnTimer = null;
        let treasureSpawnTimer = null;
        let enemyCounter = 0;
        
        // Zone system
        let currentZone = 1;
        let nextZoneScore = 100;
        let lastBossScore = 0;
        let nextBossScore = 1000;
        
        // Card system
        let activeCards = [];
        let pendingCardSelection = false;
        
        // Player buffs from cards
        let playerBuffs = {
            damageBonus: 0,
            moveSpeed: 20,
            scoreMultiplier: 1,
            damageReduction: 0,
            maxHealthBonus: 0,
            doubleStrikeChance: 0,
            lifesteal: 0,
            criticalChance: 0
        };
        
        // Zone definitions
        const zones = [
            { name: 'Plains', color: '#4ecca3', emoji: 'üå±' },
            { name: 'Dark Forest', color: '#45b393', emoji: 'üå≤' },
            { name: 'Mountains', color: '#808080', emoji: '‚õ∞Ô∏è' },
            { name: 'Volcano', color: '#ff6b6b', emoji: 'üåã' },
            { name: 'Ice Realm', color: '#6bb6ff', emoji: '‚ùÑÔ∏è' },
            { name: 'Shadow Realm', color: '#9400d3', emoji: 'üåë' },
            { name: 'Heaven Gates', color: '#ffd700', emoji: '‚òÅÔ∏è' },
            { name: 'Underworld', color: '#ff0000', emoji: 'üî•' }
        ];
        
        // Card pool
        const cardPool = [
            { name: "Warrior's Strength", icon: "‚öîÔ∏è", description: "Your attacks become more powerful", effect: "damageBonus", value: 10, effectText: "+10 Damage" },
            { name: "Healing Touch", icon: "‚ù§Ô∏è", description: "Restore your vitality instantly", effect: "heal", value: 40, effectText: "Restore 2 Hearts" },
            { name: "Swift Foot", icon: "üëü", description: "Move faster across the battlefield", effect: "moveSpeed", value: 10, effectText: "+10 Movement Speed" },
            { name: "Lucky Charm", icon: "üçÄ", description: "Find more valuable treasures", effect: "scoreMultiplier", value: 0.5, effectText: "+50% Score" },
            { name: "Iron Will", icon: "üõ°Ô∏è", description: "Increase your maximum health", effect: "maxHealth", value: 1, effectText: "+1 Max Heart" },
            { name: "Double Strike", icon: "‚ö°", description: "Chance to attack twice", effect: "doubleStrike", value: 25, effectText: "25% Double Attack" },
            { name: "Stone Skin", icon: "üóø", description: "Reduce damage taken", effect: "damageReduction", value: 5, effectText: "-5 Damage Taken" },
            { name: "Treasure Hunter", icon: "üí∞", description: "Double treasure score", effect: "scoreMultiplier", value: 1, effectText: "2x Treasure Score" },
            { name: "Berserker", icon: "üò°", description: "Massive damage boost", effect: "damageBonus", value: 20, effectText: "+20 Damage" },
            { name: "Life Steal", icon: "ü©∏", description: "Heal when you damage", effect: "lifesteal", value: 10, effectText: "Heal 10 HP/hit" },
            { name: "Critical Strike", icon: "üí•", description: "Devastating attacks", effect: "critical", value: 20, effectText: "20% Crit (2x)" },
            { name: "Phoenix Heart", icon: "üî•", description: "Rise stronger", effect: "maxHealth", value: 2, effectText: "+2 Max Hearts" }
        ];
        
        // Enemy types that get progressively harder
        const enemyTypes = ['üëæ', 'üëª', 'üíÄ', 'üëπ', 'üêâ', 'üßü', 'üßõ'];
        const treasureTypes = ['ü™ô', 'üíé', 'üëë', 'üí∞'];
        const bossTypes = ['üê≤', 'üëø', 'üíÄ', 'üßô‚Äç‚ôÇÔ∏è', 'üëë', 'ü¶π‚Äç‚ôÇÔ∏è'];
        
        // Weapon damage values
        const weaponDamage = {
            'sword': 25,
            'legendary sword': 40,
            'dagger': 15,
            'axe': 30,
            'bow': 20,
            'staff': 18,
            'hammer': 35,
            'shield': 5  // minimal damage for shield
        };
        
        const examples = {
            rpg: `// Full RPG Battle with PRO features
SPAWN knight AT 50, 200 AS ‚öîÔ∏è
SPAWN dragon AT 400, 200 AS üêâ
SPAWN potion AT 250, 100 AS üß™

SET knight.health TO 100
SET knight.damage TO 20
SET dragon.health TO 150
SET dragon.damage TO 15

INVENTORY knight ADD "sword"
INVENTORY knight ADD "shield"

SAY "Boss Battle!" FOR 2000
PLAY SOUND "start"
WAIT 2000

REPEAT 3 TIMES
    // Knight attacks
    MOVE knight RIGHT 100
    ATTACK knight TARGETS dragon WITH knight.damage
    PLAY SOUND "hit"
    WAIT 1000
    
    // Dragon counters
    IF dragon.health > 0 THEN
        SUBTRACT dragon.damage FROM knight.health
        SAY "Dragon hits back!" FOR 1000
        PLAY SOUND "hit"
    END
    
    MOVE knight LEFT 100
    WAIT 1500
    
    // Use potion if needed
    IF knight.health < 50 THEN
        IF knight COLLIDES potion THEN
            HEAL knight BY 30
            REMOVE potion
            SAY "Potion used! +30 HP" FOR 1500
            PLAY SOUND "coin"
        END
    END
END

IF dragon.health <= 0 THEN
    SAY "Victory! üëë" FOR 2000
    PLAY SOUND "win"
ELSE
    SAY "Dragon survives!" FOR 2000
END`,

            treasure: `// Treasure Hunt with Collision Detection
SPAWN player AT 50, 50 AS üèÉ
SPAWN coin1 AT 150, 100 AS ü™ô
SPAWN coin2 AT 300, 200 AS ü™ô
SPAWN coin3 AT 400, 150 AS ü™ô
SPAWN gem AT 250, 250 AS üíé

SET player.score TO 0
SET coinsCollected TO 0

SAY "Collect all treasures!" FOR 2000
WAIT 2000

// Random patrol for fun
REPEAT 10 TIMES
    SET randX TO RANDOM 50, 450
    SET randY TO RANDOM 50, 350
    MOVE player TO randX, randY
    WAIT 800
    
    IF player COLLIDES coin1 THEN
        ADD 10 TO player.score
        ADD 1 TO coinsCollected
        REMOVE coin1
        PLAY SOUND "coin"
        SAY "Coin! Score: " + player.score FOR 1000
    END
    
    IF player COLLIDES coin2 THEN
        ADD 10 TO player.score
        ADD 1 TO coinsCollected
        REMOVE coin2
        PLAY SOUND "coin"
        SAY "Coin! Score: " + player.score FOR 1000
    END
    
    IF player COLLIDES coin3 THEN
        ADD 10 TO player.score
        ADD 1 TO coinsCollected
        REMOVE coin3
        PLAY SOUND "coin"
        SAY "Coin! Score: " + player.score FOR 1000
    END
    
    IF player COLLIDES gem THEN
        ADD 50 TO player.score
        REMOVE gem
        PLAY SOUND "win"
        SAY "JACKPOT! üíé Score: " + player.score FOR 2000
    END
END

SAY "Final Score: " + player.score FOR 3000`,

            maze: `// Auto-Patrol Enemy Maze
SPAWN guard1 AT 100, 100 AS üíÇ
SPAWN guard2 AT 300, 100 AS üíÇ
SPAWN player AT 50, 300 AS ü•∑
SPAWN exit AT 450, 50 AS üö™

SET player.caught TO false

SAY "Sneak to the exit! üö™" FOR 2000
WAIT 2000

// Guards patrol automatically
REPEAT 5 TIMES
    // Guard 1 patrol
    MOVE guard1 RIGHT 200
    MOVE guard1 DOWN 150
    MOVE guard1 LEFT 200
    MOVE guard1 UP 150
    
    // Guard 2 patrol  
    MOVE guard2 DOWN 200
    MOVE guard2 LEFT 150
    MOVE guard2 UP 200
    MOVE guard2 RIGHT 150
    
    // Player tries to sneak
    TELEPORT player TO 150, 250
    WAIT 500
    TELEPORT player TO 250, 180
    WAIT 500
    TELEPORT player TO 350, 120
    WAIT 500
    
    // Check if caught
    IF player COLLIDES guard1 THEN
        SET player.caught TO true
        SAY "CAUGHT! üö®" FOR 2000
        PLAY SOUND "lose"
    END
    
    IF player COLLIDES guard2 THEN
        SET player.caught TO true
        SAY "CAUGHT! üö®" FOR 2000
        PLAY SOUND "lose"
    END
    
    // Check if escaped
    IF player COLLIDES exit THEN
        SAY "ESCAPED! üéâ" FOR 2000
        PLAY SOUND "win"
    END
END`,

            boss: `// Epic Boss Fight
SPAWN hero AT 50, 200 AS ü¶∏
SPAWN boss AT 400, 200 AS üëæ
SPAWN heart1 AT 250, 100 AS ‚ù§Ô∏è
SPAWN heart2 AT 250, 300 AS ‚ù§Ô∏è

SET hero.health TO 80
SET hero.damage TO 30
SET boss.health TO 200
SET phase TO 1

INVENTORY hero ADD "legendary sword"

SAY "BOSS FIGHT BEGIN!" FOR 2000
PLAY SOUND "start"
WAIT 2000

// Phase 1
SAY "Phase 1: The Awakening" FOR 1500
WAIT 1500

REPEAT 3 TIMES
    MOVE hero RIGHT 100
    ATTACK hero TARGETS boss WITH hero.damage
    PLAY SOUND "hit"
    SAY "Boss HP: " + boss.health FOR 1000
    WAIT 1000
    
    SUBTRACT 20 FROM hero.health
    MOVE hero LEFT 100
    WAIT 1000
    
    // Grab health if needed
    IF hero.health < 50 THEN
        IF hero COLLIDES heart1 THEN
            HEAL hero BY 40
            REMOVE heart1
            PLAY SOUND "coin"
        END
    END
END

// Phase 2
IF boss.health > 0 THEN
    SAY "Phase 2: RAGE MODE! üî•" FOR 2000
    MULTIPLY boss.damage BY 2
    WAIT 2000
    
    REPEAT 2 TIMES
        SET randomX TO RANDOM 100, 400
        TELEPORT boss TO randomX, 200
        ATTACK hero TARGETS boss WITH 40
        PLAY SOUND "hit"
        WAIT 1500
    END
END

IF boss.health <= 0 THEN
    SAY "VICTORY! üëëüéâ" FOR 3000
    PLAY SOUND "win"
ELSE
    SAY "The battle continues..." FOR 2000
END`,

            random: `// Random Events Quest
SPAWN adventurer AT 50, 200 AS üßô‚Äç‚ôÇÔ∏è
SPAWN monster AT 400, 200 AS üëª

SET adventurer.health TO 100
SET adventurer.luck TO RANDOM 1, 10
SET monster.health TO 80

SAY "A random adventure begins!" FOR 2000
WAIT 2000

SAY "Your luck score: " + adventurer.luck FOR 2000
WAIT 2000

// Random events based on luck
IF adventurer.luck > 7 THEN
    SAY "Lucky day! Found treasure! üé∞" FOR 2000
    SPAWN treasure AT 250, 150 AS üí∞
    PLAY SOUND "win"
END

IF adventurer.luck < 4 THEN
    SAY "Bad luck! Extra monster! üò±" FOR 2000
    SPAWN monster2 AT 350, 100 AS üëπ
END

// Random battle outcomes
REPEAT 3 TIMES
    SET hitChance TO RANDOM 1, 100
    
    IF hitChance > 50 THEN
        MOVE adventurer RIGHT 80
        SET damage TO RANDOM 15, 35
        ATTACK adventurer TARGETS monster WITH damage
        PLAY SOUND "hit"
        SAY "Critical hit! " + damage + " damage!" FOR 1000
    ELSE
        SAY "Attack missed! üí®" FOR 1000
        PLAY SOUND "lose"
    END
    
    WAIT 1500
    MOVE adventurer LEFT 80
    WAIT 1000
END

// Random ending
SET ending TO RANDOM 1, 3

IF ending == 1 THEN
    SAY "You won with style! üéä" FOR 2000
END

IF ending == 2 THEN
    SAY "Barely survived! üòÖ" FOR 2000
END

IF ending == 3 THEN
    SAY "Legendary victory! üëë" FOR 2000
END

PLAY SOUND "win"`
        };
        
        // Audio context for sound effects
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (!soundEnabled) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'hit':
                    oscillator.frequency.value = 200;
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'coin':
                    oscillator.frequency.value = 800;
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                case 'win':
                    oscillator.frequency.value = 523.25;
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    oscillator.start(audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(783.99, audioContext.currentTime + 0.3);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'lose':
                    oscillator.frequency.value = 400;
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    oscillator.start(audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.4);
                    oscillator.stop(audioContext.currentTime + 0.4);
                    break;
                case 'start':
                    oscillator.frequency.value = 440;
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
            }
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('sound-status').textContent = soundEnabled ? 'ON' : 'OFF';
            log(soundEnabled ? 'üîä Sound enabled' : 'üîá Sound disabled');
        }
        
        function log(message, type = 'success') {
            const output = document.getElementById('output');
            const line = document.createElement('div');
            line.className = `output-line output-${type}`;
            line.textContent = message;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }
        
        function clearOutput() {
            document.getElementById('output').innerHTML = '';
        }
        
        function createSprite(name, x, y, emoji) {
            const canvas = document.getElementById('game-canvas');
            const sprite = document.createElement('div');
            sprite.className = 'sprite';
            sprite.textContent = emoji;
            sprite.style.left = x + 'px';
            sprite.style.top = y + 'px';
            sprite.id = 'sprite-' + name;
            canvas.appendChild(sprite);
            
            sprites[name] = {
                element: sprite,
                x: x,
                y: y,
                emoji: emoji
            };
            
            gameState[name] = { x, y };
            
            // Update sprite selector
            updateSpriteSelector();
        }
        
        function moveSprite(name, direction, distance) {
            if (!sprites[name]) return;
            
            const sprite = sprites[name];
            
            switch(direction.toLowerCase()) {
                case 'up':
                    sprite.y -= distance;
                    break;
                case 'down':
                    sprite.y += distance;
                    break;
                case 'left':
                    sprite.x -= distance;
                    break;
                case 'right':
                    sprite.x += distance;
                    break;
            }
            
            sprite.element.style.left = sprite.x + 'px';
            sprite.element.style.top = sprite.y + 'px';
            
            if (gameState[name]) {
                gameState[name].x = sprite.x;
                gameState[name].y = sprite.y;
            }
        }
        
        function moveSpriteToPosition(name, x, y) {
            if (!sprites[name]) return;
            
            const sprite = sprites[name];
            sprite.x = x;
            sprite.y = y;
            sprite.element.style.left = x + 'px';
            sprite.element.style.top = y + 'px';
            
            if (gameState[name]) {
                gameState[name].x = x;
                gameState[name].y = y;
            }
        }
        
        function teleportSprite(name, x, y) {
            if (!sprites[name]) return;
            
            const sprite = sprites[name];
            sprite.element.style.transition = 'none';
            sprite.x = x;
            sprite.y = y;
            sprite.element.style.left = x + 'px';
            sprite.element.style.top = y + 'px';
            
            setTimeout(() => {
                sprite.element.style.transition = 'all 0.3s ease';
            }, 50);
            
            if (gameState[name]) {
                gameState[name].x = x;
                gameState[name].y = y;
            }
        }
        
        function removeSprite(name) {
            if (sprites[name]) {
                sprites[name].element.remove();
                delete sprites[name];
                delete gameState[name];
                
                // If this was the controlled sprite, clear it
                if (controlledSprite === name) {
                    controlledSprite = null;
                }
                
                updateSpriteSelector();
            }
        }
        
        function checkCollision(name1, name2) {
            if (!sprites[name1] || !sprites[name2]) return false;
            
            const s1 = sprites[name1];
            const s2 = sprites[name2];
            
            const distance = Math.sqrt(
                Math.pow(s1.x - s2.x, 2) + Math.pow(s1.y - s2.y, 2)
            );
            
            return distance < 40;
        }
        
        function attackTarget(attacker, target, damage) {
            if (!sprites[attacker] || !sprites[target]) return;
            
            if (gameState[target] && gameState[target].health !== undefined) {
                gameState[target].health -= damage;
                updateDisplay(target + '.health', gameState[target].health);
                
                sprites[target].element.classList.add('damaged');
                setTimeout(() => {
                    if (sprites[target]) {
                        sprites[target].element.classList.remove('damaged');
                    }
                }, 300);
                
                // Collision effect
                const effect = document.createElement('div');
                effect.className = 'collision-effect';
                effect.textContent = 'üí•';
                effect.style.left = sprites[target].x + 'px';
                effect.style.top = sprites[target].y + 'px';
                effect.style.fontSize = '32px';
                document.getElementById('game-canvas').appendChild(effect);
                setTimeout(() => effect.remove(), 500);
                
                if (gameState[target].health <= 0) {
                    log(`üíÄ ${target} defeated!`, 'warning');
                    setTimeout(() => removeSprite(target), 500);
                }
            }
        }
        
        function healTarget(name, amount) {
            if (!gameState[name]) return;
            
            if (gameState[name].health !== undefined) {
                gameState[name].health += amount;
                updateDisplay(name + '.health', gameState[name].health);
                
                const effect = document.createElement('div');
                effect.className = 'collision-effect';
                effect.textContent = '‚ú®';
                effect.style.left = sprites[name].x + 'px';
                effect.style.top = sprites[name].y + 'px';
                effect.style.fontSize = '32px';
                effect.style.color = '#4ecca3';
                document.getElementById('game-canvas').appendChild(effect);
                setTimeout(() => effect.remove(), 500);
            }
        }
        
        function manageInventory(name, action, item) {
            if (!inventories[name]) inventories[name] = [];
            
            if (action === 'add') {
                inventories[name].push(item);
                log(`üì¶ ${item} added to ${name}'s inventory`);
                
                // Update menu if it's open and this is the controlled sprite
                if (controlledSprite === name) {
                    const menu = document.getElementById('inventory-menu');
                    if (menu.classList.contains('open')) {
                        updateInventoryMenuDisplay();
                    }
                }
            } else if (action === 'remove') {
                const index = inventories[name].indexOf(item);
                if (index > -1) {
                    inventories[name].splice(index, 1);
                    log(`üì¶ ${item} removed from ${name}'s inventory`);
                    
                    // Unequip if it was equipped
                    if (equippedItems[name] === item) {
                        delete equippedItems[name];
                    }
                    
                    // Update menu if it's open and this is the controlled sprite
                    if (controlledSprite === name) {
                        const menu = document.getElementById('inventory-menu');
                        if (menu.classList.contains('open')) {
                            updateInventoryMenuDisplay();
                        }
                    }
                }
            }
        }
        
        function hasInInventory(name, item) {
            return inventories[name] && inventories[name].includes(item);
        }
        
        function showMessage(text, duration) {
            return new Promise(resolve => {
                const canvas = document.getElementById('game-canvas');
                const msg = document.createElement('div');
                msg.style.position = 'absolute';
                msg.style.top = '50%';
                msg.style.left = '50%';
                msg.style.transform = 'translate(-50%, -50%)';
                msg.style.background = 'rgba(0, 0, 0, 0.9)';
                msg.style.color = '#4ecca3';
                msg.style.padding = '20px 30px';
                msg.style.borderRadius = '10px';
                msg.style.fontSize = '20px';
                msg.style.border = '2px solid #4ecca3';
                msg.style.zIndex = '1000';
                msg.textContent = text;
                canvas.appendChild(msg);
                
                setTimeout(() => {
                    canvas.removeChild(msg);
                    resolve();
                }, duration);
            });
        }
        
        function updateDisplay(property, value) {
            if (property.includes('health')) {
                updateHealthHearts(value);
            } else if (property.includes('score')) {
                document.getElementById('score-display').textContent = `‚≠ê Score: ${value}`;
            }
        }
        
        function updateHealthHearts(health) {
            const hearts = document.querySelectorAll('.heart');
            const heartsToShow = Math.max(0, Math.min(5, Math.ceil(health / 20))); // 100 health = 5 hearts, 20 health per heart
            
            hearts.forEach((heart, index) => {
                if (index < heartsToShow) {
                    heart.classList.remove('lost');
                } else {
                    heart.classList.add('lost');
                }
            });
        }
        
        function toggleInventoryMenu() {
            const menu = document.getElementById('inventory-menu');
            menu.classList.toggle('open');
            
            if (menu.classList.contains('open')) {
                updateInventoryMenuDisplay();
            }
        }
        
        function updateInventoryMenuDisplay() {
            const itemsContainer = document.getElementById('inventory-items');
            
            if (!controlledSprite || !inventories[controlledSprite] || inventories[controlledSprite].length === 0) {
                itemsContainer.innerHTML = '<div class="no-items">No items in inventory</div>';
                return;
            }
            
            itemsContainer.innerHTML = '';
            
            inventories[controlledSprite].forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'inventory-item';
                
                const isEquipped = equippedItems[controlledSprite] === item;
                if (isEquipped) {
                    itemDiv.classList.add('equipped');
                }
                
                const itemName = item.toLowerCase();
                const damage = weaponDamage[itemName] || 10;
                
                itemDiv.innerHTML = `
                    <div>
                        <div class="inventory-item-name">${item}</div>
                        <div class="inventory-item-stats">+${damage} damage</div>
                    </div>
                    <div>
                        <button class="equip-btn ${isEquipped ? 'equipped' : ''}" onclick="toggleEquipItem('${item}')">
                            ${isEquipped ? 'UNEQUIP' : 'EQUIP'}
                        </button>
                        <button class="drop-btn" onclick="dropItem('${item}')">
                            DROP
                        </button>
                    </div>
                `;
                
                itemsContainer.appendChild(itemDiv);
            });
        }
        
        function dropItem(item) {
            if (!controlledSprite) return;
            
            // Unequip if equipped
            if (equippedItems[controlledSprite] === item) {
                delete equippedItems[controlledSprite];
            }
            
            // Remove from inventory
            const index = inventories[controlledSprite].indexOf(item);
            if (index > -1) {
                inventories[controlledSprite].splice(index, 1);
                log(`üóëÔ∏è Dropped ${item}`);
                playSound('coin');
                updateInventoryMenuDisplay();
                
                // Spawn dropped item in world
                if (sprites[controlledSprite]) {
                    const dropName = 'dropped_' + item.replace(/\s+/g, '_') + '_' + Date.now();
                    createSprite(dropName, sprites[controlledSprite].x + 40, sprites[controlledSprite].y, 'üì¶');
                }
            }
        }
        
        function toggleEquipItem(item) {
            if (!controlledSprite) return;
            
            if (equippedItems[controlledSprite] === item) {
                // Unequip
                delete equippedItems[controlledSprite];
                log(`üîì Unequipped ${item}`);
                playSound('coin');
            } else {
                // Equip
                equippedItems[controlledSprite] = item;
                log(`‚öîÔ∏è Equipped ${item}!`);
                playSound('coin');
            }
            
            updateInventoryMenuDisplay();
        }
        
        function getEquippedDamage(spriteName) {
            const equippedItem = equippedItems[spriteName];
            let baseDamage = 20;
            
            if (equippedItem) {
                const itemName = equippedItem.toLowerCase();
                baseDamage = weaponDamage[itemName] || 20;
            }
            
            // Add damage bonus from cards (only for player)
            if (spriteName === controlledSprite) {
                baseDamage += playerBuffs.damageBonus;
            }
            
            return baseDamage;
        }
        
        function getRandom(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        async function executeCommand(command) {
            if (!isRunning) return;
            
            command = command.trim();
            if (!command || command.startsWith('//')) return;
            
            // SPAWN
            const spawnMatch = command.match(/SPAWN (\w+) AT (\d+),\s*(\d+) AS (.+)/i);
            if (spawnMatch) {
                const [, name, x, y, emoji] = spawnMatch;
                createSprite(name, parseInt(x), parseInt(y), emoji.trim());
                log(`‚úì Spawned ${name} at (${x}, ${y})`);
                return;
            }
            
            // MOVE with direction
            const moveMatch = command.match(/MOVE (\w+) (UP|DOWN|LEFT|RIGHT) (\d+)/i);
            if (moveMatch) {
                const [, name, direction, distance] = moveMatch;
                moveSprite(name, direction, parseInt(distance));
                log(`‚úì Moved ${name} ${direction} by ${distance}`);
                await new Promise(resolve => setTimeout(resolve, 300));
                return;
            }
            
            // MOVE TO position
            const moveToMatch = command.match(/MOVE (\w+) TO (\d+),\s*(\d+)/i);
            if (moveToMatch) {
                const [, name, x, y] = moveToMatch;
                moveSpriteToPosition(name, parseInt(x), parseInt(y));
                log(`‚úì Moved ${name} to (${x}, ${y})`);
                await new Promise(resolve => setTimeout(resolve, 300));
                return;
            }
            
            // TELEPORT
            const teleportMatch = command.match(/TELEPORT (\w+) TO (\d+),\s*(\d+)/i);
            if (teleportMatch) {
                const [, name, x, y] = teleportMatch;
                teleportSprite(name, parseInt(x), parseInt(y));
                log(`‚úì Teleported ${name} to (${x}, ${y})`);
                return;
            }
            
            // REMOVE
            const removeMatch = command.match(/REMOVE (\w+)/i);
            if (removeMatch) {
                const name = removeMatch[1];
                removeSprite(name);
                log(`‚úì Removed ${name}`);
                return;
            }
            
            // ATTACK
            const attackMatch = command.match(/ATTACK (\w+) TARGETS (\w+) WITH (\d+)/i);
            if (attackMatch) {
                const [, attacker, target, damage] = attackMatch;
                attackTarget(attacker, target, parseInt(damage));
                playSound('hit');
                log(`‚öîÔ∏è ${attacker} attacks ${target} for ${damage} damage!`);
                await new Promise(resolve => setTimeout(resolve, 500));
                return;
            }
            
            // HEAL
            const healMatch = command.match(/HEAL (\w+) BY (\d+)/i);
            if (healMatch) {
                const [, name, amount] = healMatch;
                healTarget(name, parseInt(amount));
                playSound('coin');
                log(`‚ú® ${name} healed by ${amount}!`);
                return;
            }
            
            // INVENTORY
            const invMatch = command.match(/INVENTORY (\w+) (ADD|REMOVE) "(.+)"/i);
            if (invMatch) {
                const [, name, action, item] = invMatch;
                manageInventory(name, action.toLowerCase(), item);
                return;
            }
            
            // PLAY SOUND
            const soundMatch = command.match(/PLAY SOUND "(.+)"/i);
            if (soundMatch) {
                playSound(soundMatch[1]);
                return;
            }
            
            // SAY
            const sayMatch = command.match(/SAY "(.+)" FOR (\d+)/i);
            if (sayMatch) {
                const [, text, duration] = sayMatch;
                
                // Handle variable substitution
                let displayText = text;
                const varMatches = text.matchAll(/(\w+)\.(\w+)/g);
                for (const match of varMatches) {
                    const [full, name, prop] = match;
                    if (gameState[name] && gameState[name][prop] !== undefined) {
                        displayText = displayText.replace(full, gameState[name][prop]);
                    }
                }
                
                // Handle direct variable substitution
                const directVarMatches = text.matchAll(/(?<!")(\w+)(?!")/g);
                for (const match of directVarMatches) {
                    const varName = match[1];
                    if (gameState[varName] !== undefined && typeof gameState[varName] !== 'object') {
                        displayText = displayText.replace(new RegExp(`(?<!")${varName}(?!")`, 'g'), gameState[varName]);
                    }
                }
                
                log(`üí¨ "${displayText}"`);
                await showMessage(displayText, parseInt(duration));
                return;
            }
            
            // WAIT
            const waitMatch = command.match(/WAIT (\d+)/i);
            if (waitMatch) {
                const duration = parseInt(waitMatch[1]);
                await new Promise(resolve => setTimeout(resolve, duration));
                return;
            }
            
            // SET with RANDOM
            const setRandomMatch = command.match(/SET (\w+) TO RANDOM (\d+),\s*(\d+)/i);
            if (setRandomMatch) {
                const [, varName, min, max] = setRandomMatch;
                const value = getRandom(parseInt(min), parseInt(max));
                gameState[varName] = value;
                log(`‚úì Set ${varName} = ${value} (random)`);
                return;
            }
            
            // SET
            const setMatch = command.match(/SET (\w+)\.?(\w+)? TO (.+)/i);
            if (setMatch) {
                const [, name, property, value] = setMatch;
                
                // Evaluate value if it's a variable reference
                let finalValue = value.trim();
                if (gameState[finalValue] !== undefined) {
                    finalValue = gameState[finalValue];
                } else if (!isNaN(finalValue)) {
                    finalValue = parseFloat(finalValue);
                }
                
                if (property) {
                    if (!gameState[name]) gameState[name] = {};
                    gameState[name][property] = finalValue;
                    updateDisplay(`${name}.${property}`, finalValue);
                    log(`‚úì Set ${name}.${property} = ${finalValue}`);
                } else {
                    gameState[name] = finalValue;
                    log(`‚úì Set ${name} = ${finalValue}`);
                }
                return;
            }
            
            // ADD
            const addMatch = command.match(/ADD (\d+) TO (\w+)\.?(\w+)?/i);
            if (addMatch) {
                const [, value, name, property] = addMatch;
                if (property) {
                    if (!gameState[name]) gameState[name] = {};
                    if (gameState[name][property] === undefined) gameState[name][property] = 0;
                    gameState[name][property] += parseFloat(value);
                    updateDisplay(`${name}.${property}`, gameState[name][property]);
                    log(`‚úì Added ${value} to ${name}.${property} (now ${gameState[name][property]})`);
                } else {
                    if (gameState[name] === undefined) gameState[name] = 0;
                    gameState[name] += parseFloat(value);
                    log(`‚úì Added ${value} to ${name} (now ${gameState[name]})`);
                }
                return;
            }
            
            // SUBTRACT
            const subtractMatch = command.match(/SUBTRACT (\d+) FROM (\w+)\.?(\w+)?/i);
            if (subtractMatch) {
                const [, value, name, property] = subtractMatch;
                if (property) {
                    if (!gameState[name]) gameState[name] = {};
                    if (gameState[name][property] === undefined) gameState[name][property] = 0;
                    gameState[name][property] -= parseFloat(value);
                    updateDisplay(`${name}.${property}`, gameState[name][property]);
                    log(`‚úì Subtracted ${value} from ${name}.${property} (now ${gameState[name][property]})`);
                } else {
                    if (gameState[name] === undefined) gameState[name] = 0;
                    gameState[name] -= parseFloat(value);
                    log(`‚úì Subtracted ${value} from ${name} (now ${gameState[name]})`);
                }
                return;
            }
            
            // MULTIPLY
            const multiplyMatch = command.match(/MULTIPLY (\w+)\.?(\w+)? BY (\d+)/i);
            if (multiplyMatch) {
                const [, name, property, value] = multiplyMatch;
                if (property) {
                    if (gameState[name] && gameState[name][property] !== undefined) {
                        gameState[name][property] *= parseFloat(value);
                        updateDisplay(`${name}.${property}`, gameState[name][property]);
                        log(`‚úì Multiplied ${name}.${property} by ${value} (now ${gameState[name][property]})`);
                    }
                } else {
                    if (gameState[name] !== undefined) {
                        gameState[name] *= parseFloat(value);
                        log(`‚úì Multiplied ${name} by ${value} (now ${gameState[name]})`);
                    }
                }
                return;
            }
            
            // DIVIDE
            const divideMatch = command.match(/DIVIDE (\w+)\.?(\w+)? BY (\d+)/i);
            if (divideMatch) {
                const [, name, property, value] = divideMatch;
                if (property) {
                    if (gameState[name] && gameState[name][property] !== undefined) {
                        gameState[name][property] /= parseFloat(value);
                        updateDisplay(`${name}.${property}`, gameState[name][property]);
                        log(`‚úì Divided ${name}.${property} by ${value} (now ${gameState[name][property]})`);
                    }
                } else {
                    if (gameState[name] !== undefined) {
                        gameState[name] /= parseFloat(value);
                        log(`‚úì Divided ${name} by ${value} (now ${gameState[name]})`);
                    }
                }
                return;
            }
        }
        
        async function executeProgram(code) {
            const lines = code.split('\n');
            let i = 0;
            
            while (i < lines.length && isRunning) {
                const line = lines[i].trim();
                
                // REPEAT loops
                if (line.startsWith('REPEAT')) {
                    const repeatMatch = line.match(/REPEAT (\d+) TIMES/i);
                    if (repeatMatch) {
                        const times = parseInt(repeatMatch[1]);
                        const loopStart = i + 1;
                        let loopEnd = loopStart;
                        
                        // Find END
                        let depth = 1;
                        while (loopEnd < lines.length && depth > 0) {
                            if (lines[loopEnd].trim().startsWith('REPEAT')) depth++;
                            if (lines[loopEnd].trim().startsWith('END')) depth--;
                            loopEnd++;
                        }
                        loopEnd--;
                        
                        // Execute loop
                        for (let rep = 0; rep < times && isRunning; rep++) {
                            for (let j = loopStart; j < loopEnd && isRunning; j++) {
                                await executeCommand(lines[j]);
                            }
                        }
                        
                        i = loopEnd + 1;
                        continue;
                    }
                }
                
                // IF statements
                if (line.startsWith('IF')) {
                    const conditionMatch = line.match(/IF (.+) THEN/i);
                    if (conditionMatch) {
                        const condition = conditionMatch[1];
                        const conditionResult = evaluateCondition(condition);
                        
                        if (conditionResult) {
                            i++;
                            while (i < lines.length && !lines[i].trim().startsWith('END')) {
                                await executeCommand(lines[i]);
                                i++;
                            }
                        } else {
                            while (i < lines.length && !lines[i].trim().startsWith('END')) {
                                i++;
                            }
                        }
                    }
                } else if (!line.startsWith('END')) {
                    await executeCommand(line);
                }
                
                i++;
            }
            
            if (isRunning) {
                log('‚úì Quest complete!');
            }
            isRunning = false;
        }
        
        function evaluateCondition(condition) {
            try {
                // COLLIDES check
                const collideMatch = condition.match(/(\w+) COLLIDES (\w+)/i);
                if (collideMatch) {
                    return checkCollision(collideMatch[1], collideMatch[2]);
                }
                
                // INVENTORY HAS check
                const invHasMatch = condition.match(/INVENTORY (\w+) HAS "(.+)"/i);
                if (invHasMatch) {
                    return hasInInventory(invHasMatch[1], invHasMatch[2]);
                }
                
                // Variable comparisons
                const varMatch = condition.match(/(\w+)\.?(\w+)?\s*([><=!]+)\s*(\d+)/);
                if (varMatch) {
                    const [, name, property, operator, value] = varMatch;
                    let varValue;
                    
                    if (property) {
                        varValue = gameState[name]?.[property] ?? 0;
                    } else {
                        varValue = gameState[name] ?? 0;
                    }
                    
                    const numValue = parseFloat(value);
                    
                    switch (operator) {
                        case '>': return varValue > numValue;
                        case '<': return varValue < numValue;
                        case '>=': return varValue >= numValue;
                        case '<=': return varValue <= numValue;
                        case '==': return varValue == numValue;
                        case '!=': return varValue != numValue;
                    }
                }
                return false;
            } catch (e) {
                return false;
            }
        }
        
        function runCode() {
            if (isRunning) {
                log('‚ö† Quest already running!', 'error');
                return;
            }
            
            clearOutput();
            clearCanvas();
            
            const code = document.getElementById('code-editor').value;
            isRunning = true;
            log('üéÆ Starting PRO quest...');
            
            executeProgram(code).catch(error => {
                log(`‚ùå Error: ${error.message}`, 'error');
                isRunning = false;
            });
        }
        
        function stopCode() {
            isRunning = false;
            log('‚èπÔ∏è Quest stopped');
        }
        
        function clearCanvas() {
            const canvas = document.getElementById('game-canvas');
            const spritesToRemove = canvas.querySelectorAll('.sprite, .collision-effect, .combat-prompt, .boss-warning');
            spritesToRemove.forEach(s => s.remove());
            sprites = {};
            gameState = {};
            inventories = {};
            controlledSprite = null;
            combatInProgress = false;
            treasuresCollected = [];
            equippedItems = {};
            enemyCounter = 0;
            
            // Reset zone and card systems
            currentZone = 1;
            nextZoneScore = 100;
            lastBossScore = 0;
            nextBossScore = 1000;
            activeCards = [];
            pendingCardSelection = false;
            
            // Reset player buffs
            playerBuffs = {
                damageBonus: 0,
                moveSpeed: 20,
                scoreMultiplier: 1,
                damageReduction: 0,
                maxHealthBonus: 0,
                doubleStrikeChance: 0,
                lifesteal: 0,
                criticalChance: 0
            };
            
            // Stop infinite mode
            if (infiniteModeEnabled) {
                infiniteModeEnabled = false;
                stopInfiniteSpawning();
                document.getElementById('infinite-mode-btn').style.background = '';
                document.getElementById('infinite-mode-btn').style.color = '';
                document.getElementById('infinite-display').classList.remove('active');
                document.getElementById('zone-display').classList.remove('active');
                document.getElementById('active-buffs').classList.remove('visible');
                difficultyLevel = 1;
            }
            
            // Close card overlay if open
            document.getElementById('card-overlay').classList.remove('active');
            
            // Reset displays - remove extra hearts first
            const healthBar = document.querySelector('.health-bar');
            const hearts = healthBar.querySelectorAll('.heart');
            hearts.forEach((heart, index) => {
                if (index >= 5) {
                    heart.remove(); // Remove bonus hearts
                } else {
                    heart.classList.remove('lost'); // Reset base hearts
                }
            });
            
            document.getElementById('score-display').textContent = '‚≠ê Score: 0';
            
            // Close inventory menu
            const menu = document.getElementById('inventory-menu');
            menu.classList.remove('open');
            
            updateSpriteSelector();
        }
        
        function loadExample(exampleName) {
            if (isRunning) {
                stopCode();
                setTimeout(() => {
                    document.getElementById('code-editor').value = examples[exampleName];
                }, 100);
            } else {
                document.getElementById('code-editor').value = examples[exampleName];
            }
        }
        
        function updateSpriteSelector() {
            const selector = document.getElementById('sprite-selector');
            const currentValue = selector.value;
            
            selector.innerHTML = '<option value="">Select sprite to control...</option>';
            
            Object.keys(sprites).forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = `${name} ${sprites[name].emoji}`;
                selector.appendChild(option);
            });
            
            if (currentValue && sprites[currentValue]) {
                selector.value = currentValue;
            }
        }
        
        function toggleKeyboardControl() {
            keyboardControlEnabled = !keyboardControlEnabled;
            const btn = document.getElementById('keyboard-toggle-btn');
            const info = document.getElementById('control-info');
            
            if (keyboardControlEnabled) {
                btn.textContent = 'üéπ Disable WASD Control';
                btn.style.background = '#ff6b6b';
                info.style.color = '#4ecca3';
                info.textContent = '‚úì Keyboard control ACTIVE! Select a sprite and use W/A/S/D';
                
                // Add keyboard listener
                if (!keyboardListener) {
                    keyboardListener = function(e) {
                        if (!keyboardControlEnabled || !controlledSprite || combatInProgress) return;
                        
                        const moveDistance = playerBuffs.moveSpeed;
                        let moved = false;
                        
                        switch(e.key.toLowerCase()) {
                            case 'w':
                                e.preventDefault();
                                moveSprite(controlledSprite, 'up', moveDistance);
                                moved = true;
                                break;
                            case 's':
                                e.preventDefault();
                                moveSprite(controlledSprite, 'down', moveDistance);
                                moved = true;
                                break;
                            case 'a':
                                e.preventDefault();
                                moveSprite(controlledSprite, 'left', moveDistance);
                                moved = true;
                                break;
                            case 'd':
                                e.preventDefault();
                                moveSprite(controlledSprite, 'right', moveDistance);
                                moved = true;
                                break;
                        }
                        
                        // Check for collisions after moving
                        if (moved) {
                            setTimeout(() => {
                                checkTreasureCollision();
                                checkCombatCollision();
                            }, 100);
                        }
                    };
                    document.addEventListener('keydown', keyboardListener);
                }
                
                log('üéÆ Keyboard control enabled! Select a sprite to control.');
            } else {
                btn.textContent = 'üéπ Enable WASD Control';
                btn.style.background = '';
                info.style.color = '#ffd700';
                info.textContent = 'Press W/A/S/D to move ‚Ä¢ Speed: 20px per key';
                
                // Remove highlight from controlled sprite
                if (controlledSprite && sprites[controlledSprite]) {
                    sprites[controlledSprite].element.classList.remove('controlled-sprite');
                }
                controlledSprite = null;
                
                log('üéÆ Keyboard control disabled.');
            }
        }
        
        function updateControlledSprite() {
            const selector = document.getElementById('sprite-selector');
            const newSprite = selector.value;
            
            // Remove highlight from old sprite
            if (controlledSprite && sprites[controlledSprite]) {
                sprites[controlledSprite].element.classList.remove('controlled-sprite');
            }
            
            // Set new controlled sprite
            if (newSprite && sprites[newSprite]) {
                controlledSprite = newSprite;
                sprites[controlledSprite].element.classList.add('controlled-sprite');
                log(`üéÆ Now controlling: ${controlledSprite} ${sprites[controlledSprite].emoji}`);
            } else {
                controlledSprite = null;
            }
        }
        
        function toggleInfiniteMode() {
            infiniteModeEnabled = !infiniteModeEnabled;
            const btn = document.getElementById('infinite-mode-btn');
            const display = document.getElementById('infinite-display');
            const zoneDisplay = document.getElementById('zone-display');
            
            if (infiniteModeEnabled) {
                btn.style.background = '#4ecca3';
                btn.style.color = '#1a1a2e';
                display.classList.add('active');
                zoneDisplay.classList.add('active');
                
                // Initialize hero if not exists
                if (!controlledSprite) {
                    const heroExists = Object.keys(sprites).some(name => 
                        name.toLowerCase().includes('hero') || 
                        name.toLowerCase().includes('player')
                    );
                    
                    if (!heroExists) {
                        createSprite('hero', 250, 200, 'üßô');
                        gameState['hero'] = { health: 100, score: 0 };
                        updateDisplay('hero.health', 100);
                        updateDisplay('hero.score', 0);
                    }
                }
                
                // Reset zone and show initial card selection
                currentZone = 1;
                nextZoneScore = 100;
                nextBossScore = 1000;
                updateZoneDisplay();
                
                difficultyLevel = 1;
                updateDifficultyDisplay();
                startInfiniteSpawning();
                
                // Show card selection for starting cards
                showCardSelection("üé¥ Choose Your Starting Card!", "Select 1 card to begin your journey");
                
                log('üåç Infinite Mode ACTIVATED! Choose your starting card!');
            } else {
                btn.style.background = '';
                btn.style.color = '';
                display.classList.remove('active');
                zoneDisplay.classList.remove('active');
                stopInfiniteSpawning();
                log('üåç Infinite Mode deactivated');
            }
        }
        
        function showCardSelection(title, subtitle) {
            if (pendingCardSelection) return;
            
            pendingCardSelection = true;
            combatInProgress = true; // Pause game during selection
            
            const overlay = document.getElementById('card-overlay');
            document.getElementById('card-title').textContent = title;
            document.getElementById('card-subtitle').textContent = subtitle;
            
            // Generate 3 random cards
            const cardsContainer = document.getElementById('cards-container');
            cardsContainer.innerHTML = '';
            
            const shuffled = [...cardPool].sort(() => Math.random() - 0.5);
            const selectedCards = shuffled.slice(0, 3);
            
            selectedCards.forEach(card => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                cardDiv.innerHTML = `
                    <div class="card-icon">${card.icon}</div>
                    <div class="card-name">${card.name}</div>
                    <div class="card-description">${card.description}</div>
                    <div class="card-effect">${card.effectText}</div>
                `;
                cardDiv.onclick = () => selectCard(card);
                cardsContainer.appendChild(cardDiv);
            });
            
            overlay.classList.add('active');
            playSound('coin');
        }
        
        function selectCard(card) {
            const overlay = document.getElementById('card-overlay');
            overlay.classList.remove('active');
            
            // Apply card effect
            applyCardEffect(card);
            
            // Add to active cards
            activeCards.push(card);
            updateActiveBuffsDisplay();
            
            pendingCardSelection = false;
            combatInProgress = false;
            
            playSound('win');
            log(`üé¥ Selected: ${card.name} - ${card.effectText}`);
        }
        
        function applyCardEffect(card) {
            if (!controlledSprite) return;
            
            switch(card.effect) {
                case 'damageBonus':
                    playerBuffs.damageBonus += card.value;
                    break;
                case 'heal':
                    if (gameState[controlledSprite]) {
                        gameState[controlledSprite].health = Math.min(
                            gameState[controlledSprite].health + card.value,
                            (maxHealth + playerBuffs.maxHealthBonus) * 20
                        );
                        updateDisplay(controlledSprite + '.health', gameState[controlledSprite].health);
                    }
                    break;
                case 'moveSpeed':
                    playerBuffs.moveSpeed += card.value;
                    break;
                case 'scoreMultiplier':
                    playerBuffs.scoreMultiplier += card.value;
                    break;
                case 'maxHealth':
                    playerBuffs.maxHealthBonus += card.value;
                    // Add hearts to display
                    const healthBar = document.querySelector('.health-bar');
                    for (let i = 0; i < card.value; i++) {
                        const heart = document.createElement('span');
                        heart.className = 'heart';
                        heart.textContent = '‚ù§Ô∏è';
                        healthBar.appendChild(heart);
                    }
                    // Heal to new max
                    if (gameState[controlledSprite]) {
                        gameState[controlledSprite].health = Math.min(
                            gameState[controlledSprite].health + (card.value * 20),
                            (maxHealth + playerBuffs.maxHealthBonus) * 20
                        );
                        updateDisplay(controlledSprite + '.health', gameState[controlledSprite].health);
                    }
                    break;
                case 'doubleStrike':
                    playerBuffs.doubleStrikeChance += card.value;
                    break;
                case 'damageReduction':
                    playerBuffs.damageReduction += card.value;
                    break;
                case 'lifesteal':
                    playerBuffs.lifesteal += card.value;
                    break;
                case 'critical':
                    playerBuffs.criticalChance += card.value;
                    break;
            }
        }
        
        function updateActiveBuffsDisplay() {
            const buffsList = document.getElementById('buffs-list');
            const buffsContainer = document.getElementById('active-buffs');
            
            if (activeCards.length === 0) {
                buffsContainer.classList.remove('visible');
                return;
            }
            
            buffsContainer.classList.add('visible');
            buffsList.innerHTML = '';
            
            activeCards.forEach(card => {
                const buffDiv = document.createElement('div');
                buffDiv.className = 'buff-item';
                buffDiv.textContent = `${card.icon} ${card.name}`;
                buffsList.appendChild(buffDiv);
            });
        }
        
        function updateZoneDisplay() {
            const zone = zones[Math.min(currentZone - 1, zones.length - 1)];
            document.getElementById('zone-name').innerHTML = `${zone.emoji} Zone ${currentZone}: ${zone.name}`;
            
            if (controlledSprite && gameState[controlledSprite]) {
                const currentScore = gameState[controlledSprite].score || 0;
                const remaining = Math.max(0, nextZoneScore - currentScore);
                document.getElementById('zone-progress').textContent = `${currentScore}/${nextZoneScore} to next zone`;
            }
        }
        
        function checkZoneProgression() {
            if (!controlledSprite || !gameState[controlledSprite]) return;
            
            const currentScore = gameState[controlledSprite].score || 0;
            
            // Check for zone progression
            if (currentScore >= nextZoneScore && !pendingCardSelection) {
                currentZone++;
                nextZoneScore += 100; // Each zone needs 100 more points
                
                playSound('win');
                log(`üåü ZONE UP! Entered Zone ${currentZone}!`, 'warning');
                
                updateZoneDisplay();
                
                // Show card selection for new zone
                const zone = zones[Math.min(currentZone - 1, zones.length - 1)];
                showCardSelection(
                    `${zone.emoji} Entered ${zone.name}!`,
                    "Choose a card to power up!"
                );
            }
            
            // Check for boss battle
            if (currentScore >= nextBossScore && currentScore > lastBossScore && !pendingCardSelection) {
                lastBossScore = currentScore;
                nextBossScore = currentScore + 500; // Next boss in 500 points
                
                spawnBoss();
            }
        }
        
        function spawnBoss() {
            combatInProgress = true;
            
            // Show boss warning
            const canvas = document.getElementById('game-canvas');
            const warning = document.createElement('div');
            warning.className = 'boss-warning';
            warning.innerHTML = `
                <h2>‚ö†Ô∏è BOSS APPROACHING! ‚ö†Ô∏è</h2>
                <p>A powerful foe emerges!</p>
            `;
            canvas.appendChild(warning);
            
            playSound('start');
            
            setTimeout(() => {
                warning.remove();
                
                // Spawn the boss
                const bossName = 'BOSS_' + Date.now();
                const bossEmoji = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                const bossHealth = 200 + (currentZone * 50); // Scales with zones
                
                // Random edge spawn
                const side = Math.floor(Math.random() * 4);
                let x, y;
                switch(side) {
                    case 0: x = 250; y = 10; break;
                    case 1: x = 460; y = 200; break;
                    case 2: x = 250; y = 360; break;
                    case 3: x = 10; y = 200; break;
                }
                
                createSprite(bossName, x, y, bossEmoji);
                gameState[bossName] = { health: bossHealth, isBoss: true };
                
                log(`üëë BOSS SPAWNED: ${bossEmoji} (HP: ${bossHealth})!`, 'warning');
                
                combatInProgress = false;
            }, 3000);
        }
        
        function startInfiniteSpawning() {
            // Spawn enemies every 3-5 seconds (faster as difficulty increases)
            const spawnDelay = Math.max(2000, 5000 - (difficultyLevel * 200));
            
            enemySpawnTimer = setInterval(() => {
                if (infiniteModeEnabled && !combatInProgress) {
                    spawnRandomEnemy();
                }
            }, spawnDelay);
            
            // Spawn treasures every 8-12 seconds
            treasureSpawnTimer = setInterval(() => {
                if (infiniteModeEnabled) {
                    spawnRandomTreasure();
                }
            }, 10000);
            
            // Increase difficulty every 30 seconds
            setInterval(() => {
                if (infiniteModeEnabled && difficultyLevel < 10) {
                    difficultyLevel++;
                    updateDifficultyDisplay();
                    log(`‚ö†Ô∏è Difficulty increased to level ${difficultyLevel}!`, 'warning');
                    
                    // Restart spawning with new speed
                    clearInterval(enemySpawnTimer);
                    const newSpawnDelay = Math.max(2000, 5000 - (difficultyLevel * 200));
                    enemySpawnTimer = setInterval(() => {
                        if (infiniteModeEnabled && !combatInProgress) {
                            spawnRandomEnemy();
                        }
                    }, newSpawnDelay);
                }
            }, 30000);
        }
        
        function stopInfiniteSpawning() {
            if (enemySpawnTimer) {
                clearInterval(enemySpawnTimer);
                enemySpawnTimer = null;
            }
            if (treasureSpawnTimer) {
                clearInterval(treasureSpawnTimer);
                treasureSpawnTimer = null;
            }
        }
        
        function spawnRandomEnemy() {
            enemyCounter++;
            const enemyName = 'enemy_' + enemyCounter;
            
            // Choose enemy type based on difficulty
            const enemyIndex = Math.min(Math.floor(difficultyLevel / 2), enemyTypes.length - 1);
            const enemyEmoji = enemyTypes[enemyIndex];
            
            // Random position at edges of canvas, avoiding UI
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            switch(side) {
                case 0: // top - avoid left UI area
                    x = 220 + Math.random() * 280; // Start after UI on left
                    y = 10;
                    break;
                case 1: // right
                    x = 460;
                    y = Math.random() * 400;
                    break;
                case 2: // bottom - avoid left UI area
                    x = 220 + Math.random() * 280;
                    y = 360;
                    break;
                case 3: // left - spawn in middle/bottom areas only to avoid top UI
                    x = 10;
                    y = 140 + Math.random() * 220; // Start below UI elements
                    break;
            }
            
            createSprite(enemyName, x, y, enemyEmoji);
            
            // Set health based on difficulty (50 + 20 per level)
            const enemyHealth = 50 + (difficultyLevel * 20);
            gameState[enemyName] = { health: enemyHealth };
            
            log(`üëπ ${enemyEmoji} spawned! (HP: ${enemyHealth})`);
        }
        
        function spawnRandomTreasure() {
            const treasureName = 'treasure_' + Date.now();
            const treasureEmoji = treasureTypes[Math.floor(Math.random() * treasureTypes.length)];
            
            // Avoid UI areas when spawning
            // Top-left has health/score (0-220px wide, 0-120px tall)
            // Bottom-left has inventory (0-220px wide, 320-400px tall)
            
            let x, y;
            let validPosition = false;
            
            while (!validPosition) {
                x = 50 + Math.random() * 400;
                y = 50 + Math.random() * 300;
                
                // Check if position overlaps with UI
                const inTopLeftUI = (x < 220 && y < 120);
                const inBottomLeftUI = (x < 220 && y > 280);
                
                if (!inTopLeftUI && !inBottomLeftUI) {
                    validPosition = true;
                }
            }
            
            createSprite(treasureName, x, y, treasureEmoji);
            log(`‚ú® Treasure spawned at (${Math.floor(x)}, ${Math.floor(y)})`);
        }
        
        function updateDifficultyDisplay() {
            document.getElementById('difficulty-level').textContent = difficultyLevel;
            const percentage = Math.min(100, (difficultyLevel / 10) * 100);
            document.getElementById('difficulty-fill').style.width = percentage + '%';
        }
        
        function toggleFullscreen() {
            const canvas = document.getElementById('game-canvas');
            canvas.classList.toggle('fullscreen');
            
            if (canvas.classList.contains('fullscreen')) {
                log('‚õ∂ Fullscreen mode enabled');
            } else {
                log('‚õ∂ Fullscreen mode disabled');
            }
        }
        
        function checkCombatCollision() {
            if (!controlledSprite || combatInProgress) return;
            
            // Check collision with enemies/heroes
            for (let spriteName in sprites) {
                if (spriteName === controlledSprite) continue;
                
                const isHeroControlled = controlledSprite.toLowerCase().includes('hero') || 
                                        controlledSprite.toLowerCase().includes('player') ||
                                        controlledSprite.toLowerCase().includes('knight');
                const isEnemyTarget = spriteName.toLowerCase().includes('enemy') || 
                                     spriteName.toLowerCase().includes('dragon') ||
                                     spriteName.toLowerCase().includes('monster') ||
                                     spriteName.toLowerCase().includes('boss') ||
                                     spriteName.toLowerCase().includes('guard');
                
                const isEnemyControlled = controlledSprite.toLowerCase().includes('enemy') || 
                                         controlledSprite.toLowerCase().includes('dragon') ||
                                         controlledSprite.toLowerCase().includes('monster') ||
                                         controlledSprite.toLowerCase().includes('boss') ||
                                         controlledSprite.toLowerCase().includes('guard');
                const isHeroTarget = spriteName.toLowerCase().includes('hero') || 
                                    spriteName.toLowerCase().includes('player') ||
                                    spriteName.toLowerCase().includes('knight');
                
                // Combat collision
                if ((isHeroControlled && isEnemyTarget) || (isEnemyControlled && isHeroTarget)) {
                    if (checkCollision(controlledSprite, spriteName)) {
                        showCombatPrompt(controlledSprite, spriteName);
                        return;
                    }
                }
            }
        }
        
        function checkTreasureCollision() {
            if (!controlledSprite) return;
            
            // Only heroes can collect treasure
            const isHero = controlledSprite.toLowerCase().includes('hero') || 
                          controlledSprite.toLowerCase().includes('player') ||
                          controlledSprite.toLowerCase().includes('knight');
            
            if (!isHero) return;
            
            for (let spriteName in sprites) {
                if (spriteName === controlledSprite) continue;
                
                const isTreasure = spriteName.toLowerCase().includes('treasure') || 
                                  spriteName.toLowerCase().includes('coin') ||
                                  spriteName.toLowerCase().includes('gem') ||
                                  spriteName.toLowerCase().includes('gold');
                
                if (isTreasure && checkCollision(controlledSprite, spriteName)) {
                    // Check if already collected
                    if (treasuresCollected.includes(spriteName)) continue;
                    
                    treasuresCollected.push(spriteName);
                    
                    // Add score with multiplier
                    if (!gameState[controlledSprite]) gameState[controlledSprite] = {};
                    if (gameState[controlledSprite].score === undefined) {
                        gameState[controlledSprite].score = 0;
                    }
                    
                    let basePoints = spriteName.toLowerCase().includes('gem') || 
                                    spriteName.toLowerCase().includes('gold') ? 100 : 10;
                    
                    // Apply score multiplier from cards
                    const points = Math.floor(basePoints * (1 + playerBuffs.scoreMultiplier));
                    
                    gameState[controlledSprite].score += points;
                    updateDisplay(controlledSprite + '.score', gameState[controlledSprite].score);
                    
                    // Check for zone progression
                    checkZoneProgression();
                    updateZoneDisplay();
                    
                    playSound('coin');
                    log(`üí∞ Collected ${spriteName}! +${points} points! Score: ${gameState[controlledSprite].score}`);
                    
                    // Visual effect
                    const effect = document.createElement('div');
                    effect.className = 'collision-effect';
                    effect.textContent = '‚ú®';
                    effect.style.left = sprites[spriteName].x + 'px';
                    effect.style.top = sprites[spriteName].y + 'px';
                    effect.style.fontSize = '32px';
                    effect.style.color = '#ffd700';
                    document.getElementById('game-canvas').appendChild(effect);
                    setTimeout(() => effect.remove(), 500);
                    
                    // Remove treasure
                    removeSprite(spriteName);
                }
            }
        }
        
        function showCombatPrompt(attacker, target) {
            combatInProgress = true;
            
            const canvas = document.getElementById('game-canvas');
            const prompt = document.createElement('div');
            prompt.className = 'combat-prompt';
            prompt.innerHTML = `
                <h3>‚öîÔ∏è BATTLE!</h3>
                <p style="color: #e8e8e8; margin-bottom: 20px;">
                    ${attacker} encounters ${target}!
                </p>
                <button class="combat-btn" onclick="resolveCombat('${attacker}', '${target}', true)">
                    ‚öîÔ∏è ATTACK!
                </button>
                <button class="combat-btn defend" onclick="resolveCombat('${attacker}', '${target}', false)">
                    üõ°Ô∏è RETREAT
                </button>
            `;
            prompt.id = 'combat-prompt';
            canvas.appendChild(prompt);
        }
        
        function resolveCombat(attacker, target, didAttack) {
            const prompt = document.getElementById('combat-prompt');
            if (prompt) prompt.remove();
            
            if (!didAttack) {
                log(`üõ°Ô∏è ${attacker} retreats!`);
                combatInProgress = false;
                return;
            }
            
            // 50/50 chance
            const success = Math.random() < 0.5;
            let damage = getEquippedDamage(attacker);
            
            if (success) {
                // Check for critical strike (player only)
                let isCrit = false;
                if (attacker === controlledSprite && Math.random() * 100 < playerBuffs.criticalChance) {
                    damage *= 2;
                    isCrit = true;
                }
                
                // Hit the target
                playSound('hit');
                
                const equippedWeapon = equippedItems[attacker];
                const weaponText = equippedWeapon ? ` with ${equippedWeapon}` : '';
                const critText = isCrit ? ' üí• CRITICAL!' : '';
                log(`‚öîÔ∏è ${attacker} hits ${target}${weaponText} for ${damage} damage!${critText}`, 'success');
                
                if (gameState[target] && gameState[target].health !== undefined) {
                    gameState[target].health -= damage;
                    updateDisplay(target + '.health', gameState[target].health);
                    
                    // Lifesteal (player only)
                    if (attacker === controlledSprite && playerBuffs.lifesteal > 0) {
                        if (gameState[attacker]) {
                            const maxHP = (maxHealth + playerBuffs.maxHealthBonus) * 20;
                            gameState[attacker].health = Math.min(
                                gameState[attacker].health + playerBuffs.lifesteal,
                                maxHP
                            );
                            updateDisplay(attacker + '.health', gameState[attacker].health);
                            log(`ü©∏ Lifesteal! +${playerBuffs.lifesteal} HP`);
                        }
                    }
                    
                    if (sprites[target]) {
                        sprites[target].element.classList.add('damaged');
                        setTimeout(() => {
                            if (sprites[target]) {
                                sprites[target].element.classList.remove('damaged');
                            }
                        }, 300);
                    }
                    
                    if (gameState[target].health <= 0) {
                        // Bonus score for killing bosses
                        if (gameState[target].isBoss && attacker === controlledSprite) {
                            gameState[attacker].score = (gameState[attacker].score || 0) + 200;
                            updateDisplay(attacker + '.score', gameState[attacker].score);
                            log(`üëë BOSS DEFEATED! +200 BONUS POINTS!`, 'warning');
                            checkZoneProgression();
                            updateZoneDisplay();
                        }
                        
                        log(`üíÄ ${target} defeated!`, 'warning');
                        setTimeout(() => removeSprite(target), 500);
                    }
                }
                
                // Visual effect
                if (sprites[target]) {
                    const effect = document.createElement('div');
                    effect.className = 'collision-effect';
                    effect.textContent = isCrit ? 'üí•üí•' : 'üí•';
                    effect.style.left = sprites[target].x + 'px';
                    effect.style.top = sprites[target].y + 'px';
                    effect.style.fontSize = isCrit ? '48px' : '32px';
                    document.getElementById('game-canvas').appendChild(effect);
                    setTimeout(() => effect.remove(), 500);
                }
                
                // Double strike chance (player only)
                if (attacker === controlledSprite && Math.random() * 100 < playerBuffs.doubleStrikeChance) {
                    setTimeout(() => {
                        if (sprites[target] && gameState[target] && gameState[target].health > 0) {
                            const doubleDamage = getEquippedDamage(attacker);
                            gameState[target].health -= doubleDamage;
                            updateDisplay(target + '.health', gameState[target].health);
                            playSound('hit');
                            log(`‚ö° DOUBLE STRIKE! Additional ${doubleDamage} damage!`, 'success');
                            
                            if (gameState[target].health <= 0) {
                                setTimeout(() => removeSprite(target), 300);
                            }
                        }
                    }, 300);
                }
            } else {
                // Miss and take counter damage
                let counterDamage = getEquippedDamage(target);
                
                // Apply damage reduction (player only)
                if (attacker === controlledSprite) {
                    counterDamage = Math.max(0, counterDamage - playerBuffs.damageReduction);
                }
                
                playSound('hit');
                log(`üí¢ ${attacker} missed! ${target} counters for ${counterDamage} damage!`, 'error');
                
                if (gameState[attacker] && gameState[attacker].health !== undefined) {
                    gameState[attacker].health -= counterDamage;
                    updateDisplay(attacker + '.health', gameState[attacker].health);
                    
                    if (sprites[attacker]) {
                        sprites[attacker].element.classList.add('damaged');
                        setTimeout(() => {
                            if (sprites[attacker]) {
                                sprites[attacker].element.classList.remove('damaged');
                            }
                        }, 300);
                    }
                    
                    if (gameState[attacker].health <= 0) {
                        log(`üíÄ ${attacker} defeated!`, 'warning');
                        setTimeout(() => {
                            removeSprite(attacker);
                            if (attacker === controlledSprite) {
                                controlledSprite = null;
                                updateSpriteSelector();
                                log('üíÄ GAME OVER! Restart infinite mode to try again.', 'error');
                            }
                        }, 500);
                    }
                }
                
                // Visual effect
                if (sprites[attacker]) {
                    const effect = document.createElement('div');
                    effect.className = 'collision-effect';
                    effect.textContent = 'üí•';
                    effect.style.left = sprites[attacker].x + 'px';
                    effect.style.top = sprites[attacker].y + 'px';
                    effect.style.fontSize = '32px';
                    document.getElementById('game-canvas').appendChild(effect);
                    setTimeout(() => effect.remove(), 500);
                }
            }
            
            combatInProgress = false;
        }
    </script>
</body>
</html>
